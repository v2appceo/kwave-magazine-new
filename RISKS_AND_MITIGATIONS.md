# 개선 제안 시 예상되는 단점 및 보완 대책

개선 작업을 진행함에 있어 발생할 수 있는 **단점(Risk/Cost)** 과 이를 해결하기 위한 **보완책(Mitigation)** 은 다음과 같습니다.

## 1. 초기 개발 러닝 커브 및 복잡도 증가
*   **단점**:
    *   모든 것을 한 파일(`page.tsx`)에서 볼 수 있었던 직관성이 사라지고, 여러 파일(`Header.tsx`, `Hero.tsx` 등)을 오가며 작업해야 합니다.
    *   **Server Component**와 **Client Component**의 경계를 명확히 구분해야 하며, 이 과정에서 `Hydration Error` 등 새로운 종류의 에러를 마주할 수 있습니다.
    *   기존의 단순한 React 방식보다 Next.js App Router의 심화 개념(Server Actions, Streaming 등)을 이해해야 합니다.

*   **보완책**:
    *   **점진적 도입**: 한 번에 모든 페이지를 뒤집지 않고, `Header`나 `Footer` 같은 작은 컴포넌트부터 분리합니다.
    *   **명확한 폴더 구조**: 기능별(Feature-based) 폴더 구조를 도입하여(예: `components/home/Hero.tsx`) 관련 파일을 쉽게 찾을 수 있도록 합니다.

## 2. 작업 시간 및 비용 발생
*   **단점**:
    *   당장 눈에 보이는 새로운 기능 추가가 아니라 내부 구조를 뜯어고치는 것이므로, 단기적으로는 "진척이 없어 보일 수" 있습니다.
    *   기존에 잘 동작하던 기능을 건드리면서 일시적인 **회귀 버그(Regression Bug)** 가 발생할 가능성이 있습니다.

*   **보완책**:
    *   **단위 테스트(Unit Test) 도입**: 리팩토링 전후 기능이 동일하게 동작하는지 확인하는 테스트 코드를 작성합니다.
    *   **기능 동결(Code Freeze)**: 리팩토링 기간 동안은 대규모 신규 기능 추가를 잠시 중단하고 구조 개선에 집중합니다.

## 3. 오버엔지니어링(Over-engineering) 위험
*   **단점**:
    *   너무 작은 컴포넌트까지 과도하게 분리하거나, 당장 필요 없는 복잡한 디자인 패턴을 도입하면 오히려 코드가 더 난해해질 수 있습니다.
    *   "나중에 필요할 것 같아서" 미리 만드는 추상화는 대부분 불필요한 복잡도만 높입니다 (YAGNI 원칙 위배).

*   **보완책**:
    *   **Rule of Three**: 코드가 **3번 이상 중복**될 때만 컴포넌트로 분리합니다. 2번까지는 중복을 허용하는 등 유연함을 둡니다.
    *   **실용주의적 접근**: 현재 프로젝트 규모에 맞는 적정 수준의 분리만 수행합니다.

## 4. 서버 부하 증가 가능성
*   **단점**:
    *   기존에 클라이언트(사용자 브라우저)에서 처리하던 연산을 서버에서 수행하게 되므로, 트래픽이 몰릴 경우 웹 서버의 CPU/Memory 사용량이 늘어날 수 있습니다.

*   **보완책**:
    *   **캐싱(Caching) 전략**: Next.js의 강력한 캐싱 기능(`revalidate`)을 활용하여, 매 요청마다 DB를 조회하지 않고 일정 시간 동안 저장된 결과를 보여줍니다.
    *   **CDN 활용**: 정적 에셋이나 캐시된 페이지는 Vercel Edge Network(CDN)에서 처리하도록 하여 원본 서버 부하를 줄입니다.

---

## 📋 결론 요약

> **"단기적인 고통, 장기적인 평화"**

리팩토링 과정에서 **일시적인 복잡도 증가와 개발 시간 투자**는 불가피합니다. 하지만 이를 감수하고 구조를 잡아두지 않으면, 프로젝트가 커질수록 **기능 추가 속도가 현저히 느려지고 버그가 속출하는 "기술 부채(Technical Debt)"의 늪**에 빠지게 됩니다.

따라서 **지금이 가장 저렴하게 구조를 개선할 수 있는 골든 타임**이며, 위 보완책들을 통해 리스크를 최소화하며 진행하는 것을 권장합니다.
